**题目1，实现一个 promiseTimeout 方法**：
实现：promiseTimeout（promise， time）
若参数2的时间结束时，参数1的promise还处于pending，则返回一个reject err的promise；
若参数2的时间结束内，参数1的promise状态改变，则返回这个promise

```typescript
  // 思路，使用 Promise.race 来对比promise 和一个time时间后reject的promise的执行速度,哪个快则返回哪个promise
  const normalPromise = (time) => new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('success')
    }, time)
  })
  const rejectPromise = (time) => new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('promise time out'))
    }, time)
  })

  const fn = (time1, time2) => Promise.race([normalPromise(time1), rejectPromise(time2)])

  fn(1000, 2000).then((val) => {
    console.log('vv', val)
  }, (err) => {
    console.log('er', err)
  })
}
```

**题目2，按址传递**：
> 浅拷贝是引用的拷贝，深拷贝是值的拷贝
```typescript
  let arr = [1, 2, 3]
  let obj = {}
  function fn(ar, ob) {
    ar = [] // 更换ar指针指向（强引用的更改），但原来指向的那个数组内存还是依然存在没有改动
    ob.a = 'a' // 修改到obj指向的那片堆区内存，对象值发生改变
    ob = { b: 'b' } // 更换ob指针的指向，强引用更改，但原ob对象指向的对象没有被垃圾回收（非weakmap），且没有修改
  }
  fn(arr, obj) // arr：[1,2,3]， obj：{ a: 'a' }
```