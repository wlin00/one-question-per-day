**题目1，实现一个 promiseTimeout 方法**：
实现：promiseTimeout（promise， time）
若参数2的时间结束时，参数1的promise还处于pending，则返回一个reject err的promise；
若参数2的时间结束内，参数1的promise状态改变，则返回这个promise

```typescript
  // 思路，使用 Promise.race 来对比promise 和一个time时间后reject的promise的执行速度,哪个快则返回哪个promise
  const normalPromise = (time) => new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('success')
    }, time)
  })
  const rejectPromise = (time) => new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('promise time out'))
    }, time)
  })

  const fn = (time1, time2) => Promise.race([normalPromise(time1), rejectPromise(time2)])

  fn(1000, 2000).then((val) => {
    console.log('vv', val)
  }, (err) => {
    console.log('er', err)
  })
}
```

**题目2，按址传递**：
> 浅拷贝是引用的拷贝，深拷贝是值的拷贝
```typescript
  let arr = [1, 2, 3]
  let obj = {}
  function fn(ar, ob) {
    ar = [] // 更换ar指针指向（强引用的更改），但原来指向的那个数组内存还是依然存在没有改动
    ob.a = 'a' // 修改到obj指向的那片堆区内存，对象值发生改变
    ob = { b: 'b' } // 更换ob指针的指向，强引用更改，但原ob对象指向的对象没有被垃圾回收（非weakmap），且没有修改
  }
  fn(arr, obj) // arr：[1,2,3]， obj：{ a: 'a' }
```

**题目2，按址传递**：
> 浅拷贝是引用的拷贝，深拷贝是值的拷贝
```typescript
  let arr = [1, 2, 3]
  let obj = {}
  function fn(ar, ob) {
    ar = [] // 更换ar指针指向（强引用的更改），但原来指向的那个数组内存还是依然存在没有改动
    ob.a = 'a' // 修改到obj指向的那片堆区内存，对象值发生改变
    ob = { b: 'b' } // 更换ob指针的指向，强引用更改，但原ob对象指向的对象没有被垃圾回收（非weakmap），且没有修改
  }
  fn(arr, obj) // arr：[1,2,3]， obj：{ a: 'a' }
```

**3，防抖和节流**：
**代码：**
```JavaScript
  // 节流
  function throttle(fn, delay) {
    let timer
    return function (...arg) {
      let context = this
      if (!timer) { // 有定时器就不执行
        timer = setTimeout(() => {
          timer = null // 节流函数执行完需清空定时器
          fn && fn.apply(context, arg)
        }, delay)
      }
    }
  }

  // 防抖
  function debounce(fn, delay) {
    let timer
    return function (...arg) {
      let context = this
      if (timer) { // 每次定时器就清除
        clearTimeout(timer)
      }
      timer = setTimeout(() => {
        fn && fn.apply(context, arg)
      }, delay)
    }
  }
```

**题目4，JS实现两个大数相加**：
> 当有两个整数a和b，通常情况下我们有 `+` 运算符对其进行相加运算，但JS存在整数的时候是有一个安全范围的，一旦数字超过这个范围会损失精度，所以我们不能拿精度损失的数字进行运行，因为运算结果是一样会损失精度的，所以我们要用字符串来表示数据，不会丢失精度。

> JS中的Number类型使用IEEE 754格式的数字数据类型，是一种64位双精度浮点型，最大安全数范围是：2^53 - 1。而如 0.1 + 0.2，浮点数在十进制转为二进制的时候出现无限循环小数，所以经过运算后转为了最终的十进制后精度会丢失造成误差。
  

```typescript
  function add (str1, str2) { // let a = "9007199254740991"; let b = "1234567899999999999"
    // 对字符串进行位数补齐，在长度短的字符串前补 '0'
    const maxLen = Math.max(str1.length, str2.length)
    // 长度短的字符串前补 ‘0‘
    str1 = str1.padStart(maxLen, 0)
    str2 = str2.padStart(maxLen, 0)
    let carry = 0 // 暂存当时进位
    let res = '' // 结果数组
    for (let i = str1.length - 1; i >= 0; i--) {
      let sum = Number(str1[i]) + Number(str2[i]) + carry
      carry = Math.floor(sum / 10)
      res = sum % 10 + res
    }
    // 如果还有进位，则字符串前追加 ‘1’
    if (carry === 1) {
      res = '1' + res
    }
    return res
  }

  add('9007199254740991', '1234567899999999999') // '1243575099254740990'
```

**题目5，统计一个字符串或字符在另一个字符串中的出现次数**：
示例1：
输入：str = "abcaaadefg2333333333334abcddddea"
实现一个 getTotalCount(str, target) 方法，来获取target在str中出现了多少次

```typescript
  // 思路：递归寻找target 在 str中的下标
  function getTotalCount (str, target) {
    const findIndex = str.indexOf(target)
    if (findIndex === -1) {
      return 0
    }
    // 递归寻找 - 截取去除当前str中已经寻找过的target
    return getTotalCount(str.slice(findIndex + target.length), target) + 1
  }

  getTotalCount('abcaaadefg2333333333334abcddddea', 'abc') // 2
```

**题目6，写一个加密解密字符串的方法**：
思路：使用 string.charCodeAt() 和String.fromCharCode(code) 来对单个字符加密和解密
  
```typescript
  const encodeStr = (str, key) => { // 输入密钥对字符串内部每个字符进行 字符Unicode编码 * key 的加密 
    return str.split('').map((item) => item.charCodeAt() * key).join('#')
  }

  const decodeStr = (str, key) => { // 输入密钥计算字符串每一个字符的Unicode编码，使用String.fromCharCode解密
    return str.split('#').map((item) => String.fromCharCode(+item / key)).join('')
  }

  console.log(decodeStr(encodeStr('hello', 33), 33))
```

**题目7，写一方法把下划线转换为驼峰命名**：
输入一个 'a_bc_def' 转换为 'aBcDef'
  
```typescript
// 思路：正则表达式 分组匹配
const transformStr = (str) => { // str = 'a_bc_def'
  return str.replace(/(\w)(_)(\w)/g, (match, $1, $2, $3) => `${$1}${$3.toUpperCase()}`)
}
```