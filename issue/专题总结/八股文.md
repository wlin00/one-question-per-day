**题目1 defer 和 async**：
```typescript
  1、defer 延时加载后的文件会在DomContentLoaded事件（ready）之前执行
  2、async 是脚本异步加载好了后直接执行
```


**题目2 浏览器加载的过程**：
```typescript
  1、解析html结构
  2、加载外部js脚本和样式表文件（预扫描）
  3、解析并执行js脚本
  4、dom树构建完成 - html解析完毕（完成触发 onready 即 DomContentLoaded，defer异步加载的脚本在这个阶段之前执行）
  5、加载图片等外部文件（完成后触发图片的onload）
  6、页面加载完毕（完成后触发页面的onload）
```


**题目3 DOMContentloaded 和 onload的区别**：
```typescript
  DOMContentloaded：在html解析完毕后执行，onready可以执行多次
  onload：页面所有元素（图片、css、html）加载完成后执行，只执行一次
```

**题目4 KOA2洋葱模型**：
```typescript
  洋葱圈模型：是一种中间件的机制，通过函数式组合的概念，将一组需要顺序执行的函数，复合为一个函数。外层函数的参数实际是内层函数的返回值。
```

**题目5 encodeURI 和 encodeURIComponent的区别**：
```typescript
  encodeURI: 用于整个URI字符串每个字符的转义，但不会转义 / ？、& 等特殊字符；
  encodeURIComponent: 用于部分URI每个字符的转义，还会转义 / ？、& 等特殊字符
```

**题目6 JS的继承**：
JS常见的继承有：构造函数继承、原型链继承、组合继承、寄生组合继承

```typescript
1、构造函数继承 - 子类中调用父类构造函数的call方法
特点：子类可以通过父类创建属性，每次创建子类会调用父类的构造函数
  function Parent(name) {
    this.name = name
    this.value = 'parent'
  }
  function Child(name) {
    Parent.call(this, name) // 可借助构造函数传参数
    this.type = 'child'
  }
  const child = new Child('Alice')

2、原型链继承
特点：子类可以共享拿到父类原型上的属性，但不能通过父类创建属性
  function Parent(name) {
    this.name = name
    this.value = 'parent'
  }
  function Child() {
    this.type = 'child'
  }
  Child.prototype = new Parent()
  const child = new Child('Bob') // console.log(child.value) --> parent

3、组合继承
特点：综合原型、构造函数继承的共同特点，缺点是两次调用父类构造函数
  function Parent(name) {
    this.name = name
    this.value = 'parent'
  }
  function Child(name) {
    Parent.call(this)
    this.name = name
    this.type = 'child'
  }
  Child.prototype = new Parent()
  const child = new Child('Lucy')

3、寄生组合继承
  function Parent(name) {
    this.name = name
    this.value = 'parent'
  }
  function Child(name) {
    Parent.call(this, name)
    this.type = 'child'
  }
  Child.prototype = Object.create(Parent)
  Child.prototype.constructor = Child
  const child = new Child('Tom') // 子类实例的构造函数都会指向Child
```


**题目7 如何判断数组**：
```typescript
  1、Array.isArray 
    let arr = []
    console.log(Array.isArray(arr)) // true
  
  2、Object.prototype.toString.call(arr).slice(8, -1) // 'Array'  
```


**题目8 JSON.stringify**：
```typescript
  JSON.stringify 用于将Javascript值转换为JSON字符串
    示例：在转换大部分数据时，会将其转换为JSON字符串
    JSON.stringify({}) // '{}'
    JSON.stringify(true) // 'true'
    JSON.stringify('foo') // '"foo"'
    JSON.stringify([1, false, 'false']) // '[1, false, 'false']'
    JSON.stringify({ x: 5 }) // '{"x": 5}'
    JSON.stringify({ x: 5, y: 6 }) // '{"x": 5, "y": 6}'

    在遇到对象里值为undefined、Symbol('')、函数时，JSON.stringify会忽略
    若他们被数组包裹，则会转换为[null]
    JSON.stringify({a: '123', b: undefined, c: Symbol('c'), d: () => 'd'}) // '{"a": "123"}'
    JSON.stringify({a: ['123'], b: [undefined], c: [Symbol('c')]}) // '{"a": ['123'], "b": [null], "c": [null]}'

    在处理NaN时，会转换为null
    JSON.stringify({ a: NaN }) // '{ "a": null }'

    在处理正则的时候，会转换为空对象
    JSON.stringify({ a: /\d{1,3}/g }) // '{ "a": {} }'

    处理Date对象时，会调用toJSON()将其转换为string, 会被当作字符串处理
    JSON.stringify(new Date()) // '"2022-07-18T12:47:00.662Z"'
```

**题目9 react 中如何获取state改变后的新值**：
```typescript
  1、Class组件中，使用setState的第二个回调可以获取到最新的state状态
  state = {
    count: 1
  }
  componenDidMount () {
    this.setState({ count: 100 }, () => {
      console.log(this.state.count) // 100
    })
  }

  2、Function 组件： 
   （1）使用useEffect监听依赖改变，useEffect里再次触发相关函数
   （2）使用两次useState， 第二次直接返回上一次的值，但过程中可以拿到最新的数据
       const showDownloadDialog = () => {
         // 打开弹窗，将分页请求的pageNo改为1，然后再拉取弹窗数据
         setPageNo(1)
         setPageNo((prev) => { // 第二个useState直接返回原结果
           onSubmit()
           return prev
         })

       }


```