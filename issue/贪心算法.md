**介绍：**
贪心算法是什么？
```
  贪心的本质是：选择每一阶段的局部最优，从而达到全局最优。
  例如有一堆钞票，可以允许拿走十张，那如何拿到最大的呢？当然就是每次都拿局部最优的，则最后的总数就是全局最优解。
  而再举一个例子，就是如果有一个背包体积为n，想要把背包尽可能装满，每次如果还选最大的就不行了， 这时候需要动态规划，下一节我们再整理动规。
```

**思路：**
贪心算法其实没有固定的套路，我们需要考虑的就是使用局部最优推出全局最优。我们可以尝试推举反例，若没有能推翻这样局部最优获取全局最优的情况，则可以尝试下贪心。

**题目1，分发饼干**：
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例 1:
输入: g = [1,2,3], s = [1,1]
输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。

示例 2:
输入: g = [1,2], s = [1,2,3]
输出: 2
解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.

**代码：**

```typescript
function findContentChildren(g: number[], s: number[]): number {
  // g代表胃口数组， s代表饼干大小数组
  // 贪心思路：g、s数组排序；
  g.sort((a, b) => a - b)
  s.sort((a, b) => a - b)

  let res = 0, index = s.length - 1 // 从最大的饼干开始分发, 先给胃口最大的人，若满足胃口则换下一个人和下一块饼干；若不满足就则只换人
  for (let i = g.length - 1; i >= 0; i--) {
    if (s[index] >= g[i] && index >= 0) {
      res += 1
      index -= 1
    }
  }
  return res
}

```

**题目2，摆动序列**：
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例 1:
输入: [1,7,4,9,2,5]
输出: 6
解释: 整个序列均为摆动序列。

示例 2:
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。

思路：
  局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。
  整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。
  
**代码：**

```typescript
function wiggleMaxLength(nums: number[]): number {
    // 定义currentDiff和preDiff来表示当前向量区间的变化，和上一个向量区间的变化
    // 若上一个向量区间增幅 preDiff = 0， 则当前区间增幅只要不等于0，则当前区间判定为摆动
    // 若上一个向量区间增幅 preDiff < 0， 则当前区间增幅大于0，则当前区间判定为摆动
    // 若上一个向量区间增幅 preDiff > 0， 则当前区间增幅小于0，则当前区间判定为摆动

    let preDiff = 0, res = 1

    // 从第二项开始
    for (let i = 1; i < nums.length; i++) {
        let currentDiff = nums[i] - nums[i - 1]
        if ((preDiff <= 0 && currentDiff > 0) || (preDiff >= 0 && currentDiff < 0)) {
            res += 1
            preDiff = currentDiff
        }
    }
    return res

};

```

**题目3，最大子序和**：
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

  
**代码：**

```typescript
function maxSubArray(nums: number[]): number {
  // 贪心， 当局部和小于0， 立即舍弃，重新出发，当前累积值归0
  let res = -Infinity // 当前结果值初始化为最小数, 若比对后res < 当前子数组和， 则更新res
  let sum = 0

  for (let i = 0; i < nums.length; i++) {
      sum += nums[i]
      if (sum > res) { // 若当前局部和 大于结果值， 则更新结果
          res = sum
      }
      if (sum < 0) { // 贪心：若当前局部和小于0， 则舍弃当前值， 下一轮遍历重新开始
          sum = 0
      }
  }
  return res
};

```

**题目4，股票问题**：
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
  
**代码：**

```typescript
function maxProfit(prices: number[]): number {
  // 股票1 - 只能进行一笔交易，一轮遍历，每次更新max值和记录min值
  let min = prices[0], max = 0

  for (let i = 0; i < prices.length; i++) {
    max = Math.max(max, prices[i] - min) // 第一天卖出的话没有利润
    min = Math.min(min, prices[i])
  }

  return res
};

```

**题目5，股票问题II**：
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
  
贪心思路： 可以多次进行买卖， 则记录所有能盈利的天数， 都进行交易，所有交易累积后的利润为最大利润

**代码：**

```typescript
function maxProfit(prices: number[]): number {
  // 股票2 - 可进行多笔交易, 思路调整为统计盈利的天数
  let res = 0

  for (let i = 1; i < prices.length; i++) { // 第一天无利润可跳过
    const today = prices[i] - prices[i - 1]
    if (today > 0) {
      res += today
    }

  }

  return res
};

```
