**介绍：**
```
栈和队列的原理大家应该很熟悉了，队列是先进先出，栈是先进后出。
```

**题目1，用栈实现队列**：
使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。

示例
```typescript
  const myQueue = new MyQueue();
  queue.push(1);
  queue.push(2);
  queue.peek();  // 返回 1
  queue.pop();   // 返回 1
  queue.empty(); // 返回 false
```

**代码：**

```typescript
  /**
   * Your MyQueue object will be instantiated and called as such:
   * var obj = new MyQueue()
   * obj.push(x)
   * var param_2 = obj.pop()
   * var param_3 = obj.peek()
   * var param_4 = obj.empty()
   */

  class MyQueue {
    private stack_in: number[]
    private stack_out: number[]
    constructor() {
      // 构造函数里，初始化两个栈（一个输入栈，一个输出栈），用来模拟队列的先进先出特性
      this.stack_in = []
      this.stack_out = []
    }

    push(x: number): void {
      this.stack_in.push(x)
    }

    pop(): number {
      if (this.stack_out.length) { // 若输出栈有元素，直接pop输出栈数组最后一项
        return this.stack_out.pop()
      }
      while(this.stack_in.length) { // 若输出栈无元素，但输入栈有，则用输入栈逆序填充输出栈
        this.stack_out.push(this.stack_in.pop())
      }
      return this.stack_out.pop()
    }

    peek(): number { // peek：输出队列第一个元素，即是返回pop操作结果，但不真实删除队列末尾的那个元素
      const tmp = this.pop()
      if (tmp !== undefined) { // 将pop操作的“队列末尾删除”操作的数据影响还原
        this.stack_out.push(tmp)
      }
      return tmp
    }

    empty(): boolean {
      return this.stack_in.length === 0 && this.stack_out.length === 0
    }
  }
```


